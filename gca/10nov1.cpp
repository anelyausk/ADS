// hash function - когда бы берем какую то инфу (число/строка) и переобразуем ее в hash (число/строка)
/*
часто исп при сохранении паролей 
если мы чтото захешировали, разхешировать ее нельзя

самый тупой пример хеша:
представлены числа:
15
3
7
11
10
захещировать:
взять остаток от деления
15 % 7 = 1
3
0
4
3
тут два одинаковых значении - колиззия
хороший алгоритм хеширования снижает вероятность колизии
колизия будет всегда, но лучше бы она была на 0, 000...001 вероятности

полиноминал используем чтобы не было колизии
string s 
prefix - подстрока, с 1 эл-та до какого то
суффикс - подстрока, заканчивается в конце и начин в каком то эл-те
собственный суффикс - суффикс который совпадает со всей строкой
*/
/*
s  = ababbababa
(s[0] + s[1]*p + s[2]*p^2 + ... + s[n-1]*p^n) = ____
so use long long
p = 7? polynominal
каждый символ будет в числовом виде представлять номер алфавита а = 1, b = 2, etc 
how to do it:
    s[i] - 'a' + 1 
*/

// prefix function
// 

#include <iostream>
#include <vector>

using namespace std;

int main(){
    string s;
    cin >> s;
    const int p = 7;
    long long hash = 0, p_pow = 1;
    //оптимальный хеш:
    //H(S) = s[0] + s[1]*p + s[2]*p^2 + ... + s[n-1]*p^n
    for (int i = 0; i < s.length(); i++){
        //eдиницу плюсуем, чтобы произведение не вышло нулевым
        hash += (s[i] - 'a' + 1) * p_pow;
        p_pow *= p;
    } 
    cout << hash << endl;

    //считаем все префиксы (0-1, 0-2, 0-3, ... 0-s.length())
    //h(1) = s[0]
    //h(2) = s[0] + s[1]*p
    //... 
    vector<long long> p_pows (s.size());
    vector<long long> h (s.size());
    p_pows[0] = 1;
    //вычитываем нужные степени
    for (int i = 1; i < p_pows.size(); i++){
        p_pows[i] = p_pows[i-1] * p;
    }
    //находим хеши всех префиксов
    for (int i = 0; i < s.size(); i++){
        h[i] = (s[i] - 'a' + 1) * p_pows[i];
        if (i != 0) h[i] += h[i-1];
        cout << h[i] << " ";
    }
    cout << endl;

    return 0;
}